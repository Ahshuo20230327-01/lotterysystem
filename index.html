<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lottery Pro | Professional Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <style>
        :root {
            /* Theme Variables */
            --color-bg-body: #09090b;
            --color-bg-card: #18181b;
            --color-bg-input: #27272a;
            --color-bg-chip: #3f3f46;
            
            --color-text-main: #f4f4f5;
            --color-text-muted: #a1a1aa;
            
            --color-accent: #6366f1;
            --color-accent-hover: #4f46e5;
            --color-success: #10b981;
            --color-warning: #f59e0b;
            --color-danger: #ef4444;
            --color-border: #27272a;
            
            --radius-md: 12px;
            --radius-sm: 8px;
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
            
            --transition-fast: 0.2s ease;
        }

        /* Base Reset */
        * { box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            font-family: 'Inter', system-ui, sans-serif;
            background-color: var(--color-bg-body);
            color: var(--color-text-main);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Accessibility */
        *:focus-visible {
            outline: 2px solid var(--color-accent);
            outline-offset: 2px;
        }

        /* Typography & Layout */
        header { margin: 20px 0 30px; text-align: center; }
        h1 { 
            margin: 0; font-size: 2rem; font-weight: 800; letter-spacing: -0.025em;
            background: linear-gradient(135deg, #fff 0%, #a1a1aa 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }

        .main-container {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
            gap: 24px; width: 100%; max-width: 1200px;
        }

        /* Components: Card */
        .card {
            background: var(--color-bg-card);
            border-radius: var(--radius-md);
            padding: 24px;
            border: 1px solid var(--color-border);
            box-shadow: var(--shadow-lg);
            display: flex; flex-direction: column; height: 100%;
            position: relative; /* For absolute positioning context */
        }

        .card-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--color-border);
        }
        .card-title { font-size: 1.1rem; font-weight: 600; margin: 0; display: flex; align-items: center; gap: 10px; }
        .icon { width: 20px; height: 20px; color: var(--color-text-muted); }

        /* Components: Inputs */
        .settings-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 20px; }
        
        .input-group { 
            background: var(--color-bg-input); padding: 10px 12px; 
            border-radius: var(--radius-sm); border: 1px solid transparent; 
            transition: var(--transition-fast); 
        }
        .input-group:focus-within { border-color: var(--color-accent); background: #202022; }
        .input-group label { 
            display: block; font-size: 0.75rem; color: var(--color-text-muted); 
            font-weight: 500; margin-bottom: 4px; text-transform: uppercase; 
        }
        .input-group input { 
            width: 100%; background: transparent; border: none; 
            color: white; font-size: 1.5rem; font-family: 'JetBrains Mono', monospace; font-weight: 600; 
        }

        textarea {
            width: 100%; height: 180px; background: var(--color-bg-input);
            border: 1px solid transparent; border-radius: var(--radius-sm);
            color: var(--color-text-main); padding: 16px; font-size: 0.95rem; line-height: 1.6;
            resize: vertical; font-family: 'Inter', sans-serif; transition: var(--transition-fast);
            margin-bottom: 15px;
        }
        textarea:focus { border-color: var(--color-accent); background: #202022; }

        /* Components: Buttons */
        .btn-primary {
            width: 100%; margin-top: 20px; padding: 16px;
            border-radius: var(--radius-md); border: none;
            background: var(--color-accent); color: white;
            font-size: 1rem; font-weight: 600; cursor: pointer; transition: var(--transition-fast);
        }
        .btn-primary:hover:not(:disabled) { background: var(--color-accent-hover); transform: translateY(-1px); }
        .btn-primary:disabled { background: var(--color-bg-chip); color: var(--color-text-muted); cursor: not-allowed; }

        .btn-icon {
            background: transparent; border: 1px solid var(--color-border); color: var(--color-text-muted);
            padding: 6px 10px; border-radius: 6px; font-size: 0.8rem; cursor: pointer;
            display: flex; align-items: center; gap: 6px; transition: var(--transition-fast);
        }
        .btn-icon:hover { background: rgba(255,255,255,0.05); color: var(--color-text-main); border-color: #52525b; }

        .btn-action {
            padding: 12px; border-radius: var(--radius-sm); border: 1px solid var(--color-border);
            background: var(--color-bg-input); color: var(--color-text-main); 
            cursor: pointer; font-size: 0.9rem; font-weight: 500;
            display: flex; align-items: center; justify-content: center; gap: 8px; transition: var(--transition-fast);
        }
        .btn-action:hover:not(:disabled) { background: var(--color-bg-chip); }
        .btn-action:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-action.copied { background: var(--color-success); border-color: var(--color-success); color: white; }

        /* Components: Chips */
        .chips-container {
            display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 0; max-height: 0;
            overflow: hidden; transition: max-height 0.3s ease;
        }
        .chips-container.has-items { max-height: 100px; overflow-y: auto; margin-bottom: 15px; }
        .chip {
            background: var(--color-bg-chip); padding: 4px 8px; border-radius: 4px;
            font-size: 0.75rem; color: var(--color-text-main); 
            overflow-wrap: anywhere; word-break: break-all;
        }

        /* Components: Toggle */
        .status-bar { display: flex; justify-content: space-between; align-items: center; margin-top: auto; }
        .toggle-group { display: flex; gap: 16px; }
        .toggle-wrapper { display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none; }
        .toggle-label { font-size: 0.8rem; color: var(--color-text-muted); }
        .switch { position: relative; width: 32px; height: 18px; background: var(--color-bg-chip); border-radius: 20px; transition: 0.3s; }
        .switch::after { 
            content: ''; position: absolute; left: 2px; top: 2px; width: 14px; height: 14px; 
            background: white; border-radius: 50%; transition: 0.3s; 
        }
        input:checked + .switch { background: var(--color-accent); }
        input:checked + .switch::after { transform: translateX(14px); }

        /* Results Area */
        .result-container { 
            flex: 1; display: flex; flex-direction: column; gap: 16px; 
            position: relative; min-height: 300px;
            z-index: 1;
        }
        
        .action-bar { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: auto; padding-top: 15px; border-top: 1px solid var(--color-border); }
        
        /* Result Items - Force Visibility */
        .result-group {
            background: rgba(255,255,255,0.02); border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            opacity: 1; /* Always visible */
            transform: none; /* No transforms */
            overflow: hidden;
            display: flex; flex-direction: column; /* Ensure layout context */
        }

        .result-group.winner .group-header { background: rgba(16, 185, 129, 0.1); color: var(--color-success); }
        .result-group.backup .group-header { background: rgba(245, 158, 11, 0.1); color: var(--color-warning); }
        
        .group-header { padding: 10px 16px; font-size: 0.9rem; font-weight: 600; display: flex; justify-content: space-between; flex-shrink: 0; }
        .list-scroll { 
            max-height: 250px; 
            overflow-y: auto; 
            padding: 8px; 
            width: 100%;
        }
        
        .result-row { display: flex; padding: 8px 12px; border-radius: 4px; font-size: 0.95rem; gap: 12px; align-items: center; }
        .result-row:hover { background: rgba(255,255,255,0.05); }
        .index { font-family: 'JetBrains Mono', monospace; color: var(--color-text-muted); width: 30px; text-align: right; flex-shrink: 0; }
        
        .name { 
            color: var(--color-text-main); 
            min-width: 0; 
            flex-grow: 1;
            overflow-wrap: anywhere; 
            word-break: break-all;
            white-space: pre-wrap;
        }
        
        /* Loading & Empty States */
        /* Changed to Absolute Overlay to prevent Layout Shift */
        .state-overlay {
            position: absolute; inset: 0; 
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center; align-items: center; 
            color: var(--color-text-muted);
            background: var(--color-bg-card); /* Cover the content */
            z-index: 10;
        }
        .state-overlay.active { display: flex; }
        
        .empty-icon { font-size: 3rem; margin-bottom: 10px; filter: grayscale(1); }
        .spinner { font-size: 2rem; margin-bottom: 10px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Overlays & Utilities */
        .overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.7); backdrop-filter: blur(4px);
            z-index: 999; display: flex; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: 0.2s;
        }
        .overlay.active { opacity: 1; pointer-events: auto; }

        /* Toast */
        .toast-container { position: fixed; top: 24px; left: 50%; transform: translateX(-50%); z-index: 1000; display: flex; flex-direction: column; gap: 8px; pointer-events: none; }
        .toast { 
            background: var(--color-bg-card); color: var(--color-text-main); padding: 12px 16px; 
            border-radius: 8px; border: 1px solid var(--color-border); box-shadow: var(--shadow-lg);
            display: flex; gap: 10px; align-items: center; animation: fadeIn 0.3s;
        }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

        @media (max-width: 768px) { .main-container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>

<!-- Toast Anchor -->
<div id="toast-container" class="toast-container"></div>

<!-- Modal Overlay -->
<div id="modal-overlay" class="overlay">
    <div class="card" style="width: 90%; max-width: 400px; height: auto;">
        <h3 class="card-title" id="modal-title">ÊèêÁ§∫</h3>
        <p id="modal-body" style="color: var(--color-text-muted); line-height: 1.5; margin: 16px 0;">ÂÖßÂÆπ</p>
        <div style="display: flex; justify-content: flex-end; gap: 12px;">
            <button class="btn-icon" id="modal-cancel">ÂèñÊ∂à</button>
            <button class="btn-action" id="modal-confirm" style="background: var(--color-accent); border: none; color: white;">Á¢∫Ë™ç</button>
        </div>
    </div>
</div>

<header>
    <h1>Lottery Pro</h1>
</header>

<div class="main-container">
    <!-- Config Section -->
    <div class="card">
        <div class="card-header">
            <h2 class="card-title">
                <!-- Icon: Settings -->
                <svg class="icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"/></svg>
                ÂêçÂñÆËàáË®≠ÂÆö
            </h2>
            <button class="btn-icon" id="btn-clear">
                <!-- Icon: Trash -->
                <svg class="icon" style="width:14px; height:14px;" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg>
                Ê∏ÖÁ©∫
            </button>
        </div>

        <div class="settings-grid">
            <div class="input-group">
                <label for="input-count-main">Ê≠£Âèñ‰∫∫Êï∏</label>
                <input type="number" id="input-count-main" value="20" min="1">
            </div>
            <div class="input-group">
                <label for="input-count-backup">ÂÇôÂèñ‰∫∫Êï∏</label>
                <input type="number" id="input-count-backup" value="3" min="0">
            </div>
        </div>

        <div>
            <textarea id="input-names" placeholder="Ë´ãÂú®Ê≠§Ë≤º‰∏äÂêçÂñÆ...&#10;ÊîØÊè¥ Excel Ë§áË£ΩË≤º‰∏ä&#10;‰∏ÄË°å‰∏ÄÂÄãÂêçÂ≠ó"></textarea>
            <div id="chips-area" class="chips-container"></div>
        </div>

        <div class="status-bar">
            <div class="toggle-group">
                <label class="toggle-wrapper" title="Ëá™ÂãïÂÑ≤Â≠òËº∏ÂÖ•ÂÖßÂÆπ">
                    <input type="checkbox" id="toggle-memory" hidden>
                    <div class="switch"></div>
                    <span class="toggle-label">Ë®òÊÜ∂ÂêçÂñÆ</span>
                </label>
                <label class="toggle-wrapper" title="Ëá™ÂãïÁßªÈô§ÈáçË§áÁöÑÂêçÂ≠ó">
                    <input type="checkbox" id="toggle-dedup" hidden checked>
                    <div class="switch"></div>
                    <span class="toggle-label">ÂéªÈô§ÈáçË§á</span>
                </label>
            </div>
            <span id="label-count" style="font-family:'JetBrains Mono'; font-size:0.8rem; color:var(--color-text-muted)">0 ‰∫∫</span>
        </div>

        <button class="btn-primary" id="btn-run">ÈñãÂßãÊäΩÈÅ∏</button>
    </div>

    <!-- Result Section -->
    <div class="card">
        <div class="card-header">
            <h2 class="card-title">
                <!-- Icon: Chart/Result -->
                <svg class="icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                ÊäΩÈÅ∏ÁµêÊûú
            </h2>
            <div style="font-size:0.75rem; color:var(--color-success); background:rgba(16,185,129,0.1); padding:4px 8px; border-radius:4px;">
                üîí CSPRNG Active
            </div>
        </div>

        <div id="result-area" class="result-container">
            <!-- Loading & Empty States -->
            <div class="state-overlay active" id="state-empty">
                <div class="empty-icon">üé≤</div>
                <p>Ê∫ñÂÇôÂ∞±Á∑í</p>
            </div>
            
            <div class="state-overlay" id="state-loading">
                <div class="spinner">‚è≥</div>
                <p id="loading-text">INITIALIZING...</p>
            </div>
            
            <div id="result-list-container" style="display: flex; flex-direction: column; gap: 16px;"></div>
        </div>

        <div class="action-bar">
            <button class="btn-action" id="btn-copy" disabled>
                <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3"/></svg>
                Ë§áË£ΩÁµêÊûú
            </button>
            <button class="btn-action" id="btn-download" disabled>
                <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg>
                ‰∏ãËºâÂ†±Âëä
            </button>
        </div>
    </div>
</div>

<script>
    /**
     * @fileoverview Lottery Pro - Professional Drawing Application
     */

    const CONFIG = {
        STORAGE_KEYS: {
            NAMES: 'lottery_names',
            MEMORY_ENABLED: 'lottery_config_memory',
            DEDUP_ENABLED: 'lottery_config_dedup'
        },
        UI: {
            PREVIEW_LIMIT: 30,
            MAX_RENDER_ITEMS: 100,
            TOAST_DURATION: 3000,
            ANIMATION_DELAY: 500
        },
        REGEX: {
            INVALID_CHARS: /[\u0000-\u0008\u000B-\u001F\u007F-\u009F\u202A-\u202E\uFEFF]/g,
            LINE_SPLIT: /\r\n|\n|\r/
        }
    };

    const Utils = {
        debounce(func, wait) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        },

        dom(tag, { className = '', text = '', ...props } = {}, ...children) {
            const el = document.createElement(tag);
            if (className) el.className = className;
            if (text !== undefined && text !== null && text !== '') {
                el.textContent = String(text);
            }
            
            Object.entries(props).forEach(([key, val]) => {
                if (key.startsWith('on')) {
                    el.addEventListener(key.slice(2).toLowerCase(), val);
                } else if (key === 'style' && typeof val === 'object') {
                    Object.assign(el.style, val);
                } else {
                    el.setAttribute(key, val);
                }
            });
            children.forEach(child => {
                if (child) el.appendChild(child);
            });
            return el;
        },

        sanitize(text) {
            if (!text) return '';
            return text.replace(CONFIG.REGEX.INVALID_CHARS, '').trim();
        },

        generateFilename() {
            const now = new Date();
            const format = (n) => String(n).padStart(2, '0');
            return `Lottery_Result_${now.getFullYear()}${format(now.getMonth()+1)}${format(now.getDate())}.txt`;
        },

        safeStorageSet(key, value) {
            try { localStorage.setItem(key, value); } catch (e) { console.warn('Storage Error'); }
        },
        safeStorageGet(key) {
            try { return localStorage.getItem(key); } catch (e) { return null; }
        },
        safeStorageRemove(key) {
             try { localStorage.removeItem(key); } catch (e) {}
        }
    };

    class ToastService {
        constructor() { this.container = document.getElementById('toast-container'); }
        show(message, type = 'info') {
            const colors = { success: 'var(--color-success)', error: 'var(--color-danger)', info: 'var(--color-accent)' };
            const icons = { success: '‚úÖ', error: '‚ö†Ô∏è', info: '‚ÑπÔ∏è' };
            const toast = Utils.dom('div', { 
                className: 'toast',
                style: { borderLeft: `4px solid ${colors[type] || colors.info}` }
            }, Utils.dom('span', { text: icons[type] || icons.info }), Utils.dom('span', { text: message }));
            this.container.appendChild(toast);
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateY(-10px)';
                toast.addEventListener('transitionend', () => toast.remove());
            }, CONFIG.UI.TOAST_DURATION);
        }
    }

    class ModalService {
        constructor() {
            this.overlay = document.getElementById('modal-overlay');
            this.title = document.getElementById('modal-title');
            this.body = document.getElementById('modal-body');
            this.btnConfirm = document.getElementById('modal-confirm');
            this.btnCancel = document.getElementById('modal-cancel');
            this.callback = null;
            this._bindEvents();
        }
        _bindEvents() {
            const close = () => this._hide();
            this.btnCancel.onclick = close;
            this.overlay.onclick = (e) => { if(e.target === this.overlay) close(); };
            this.btnConfirm.onclick = () => { if (this.callback) this.callback(); close(); };
        }
        confirm(title, message, onConfirm) {
            this.title.textContent = title;
            this.body.textContent = message;
            this.callback = onConfirm;
            this.overlay.classList.add('active');
        }
        _hide() { this.overlay.classList.remove('active'); this.callback = null; }
    }

    class LotteryEngine {
        shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const randomBuffer = new Uint32Array(1);
                window.crypto.getRandomValues(randomBuffer);
                const j = Math.floor((randomBuffer[0] / (0xFFFFFFFF + 1)) * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }
        draw(candidates, mainCount, backupCount) {
            if (!candidates || candidates.length === 0) throw new Error("ÂêçÂñÆÁÇ∫Á©∫");
            const shuffled = this.shuffle(candidates);
            const winners = shuffled.slice(0, mainCount);
            const backups = shuffled.slice(mainCount, mainCount + backupCount);
            return { winners, backups };
        }
        processInput(rawValue, shouldDedup) {
            const lines = rawValue.split(CONFIG.REGEX.LINE_SPLIT)
                .map(line => Utils.sanitize(line))
                .filter(line => line !== '');
            return shouldDedup ? [...new Set(lines)] : lines;
        }
        formatReport(winners, backups, totalCount) {
            const time = new Date().toLocaleString('zh-TW');
            let text = `=== ÊäΩÈÅ∏ÁµêÊûúÂ†±Âëä ===\nÊôÇÈñì: ${time}\nÁ∏Ω‰∫∫Êï∏: ${totalCount}\n\n`;
            text += `„ÄêÊ≠£ÂèñÂêçÂñÆ„Äë(${winners.length}‰∫∫)\n`;
            winners.forEach((n, i) => text += `${i+1}. ${n}\n`);
            if (backups.length > 0) {
                text += `\n„ÄêÂÇôÂèñÂêçÂñÆ„Äë(${backups.length}‰∫∫)\n`;
                backups.forEach((n, i) => text += `ÂÇô${i+1}. ${n}\n`);
            }
            return text;
        }
    }

    class UIManager {
        constructor() {
            this.els = {
                input: document.getElementById('input-names'),
                chips: document.getElementById('chips-area'),
                countLabel: document.getElementById('label-count'),
                resultContainer: document.getElementById('result-list-container'),
                stateEmpty: document.getElementById('state-empty'),
                stateLoading: document.getElementById('state-loading'),
                loadingText: document.getElementById('loading-text'),
                btnRun: document.getElementById('btn-run'),
                btnCopy: document.getElementById('btn-copy'),
                btnDownload: document.getElementById('btn-download')
            };
        }

        updatePreview(names) {
            this.els.countLabel.textContent = `${names.length} ‰∫∫`;
            this.els.chips.innerHTML = '';
            if (names.length === 0) { this.els.chips.classList.remove('has-items'); return; }
            this.els.chips.classList.add('has-items');
            const fragment = document.createDocumentFragment();
            const displayLimit = CONFIG.UI.PREVIEW_LIMIT;
            names.slice(0, displayLimit).forEach(name => {
                fragment.appendChild(Utils.dom('div', { className: 'chip', text: name }));
            });
            if (names.length > displayLimit) {
                fragment.appendChild(Utils.dom('div', { className: 'chip', style: { opacity: 0.6 }, text: `+${names.length - displayLimit} more` }));
            }
            this.els.chips.appendChild(fragment);
        }

        setLoading(isLoading) {
            this.els.btnRun.disabled = isLoading;
            if (isLoading) {
                this.els.stateEmpty.classList.remove('active');
                this.els.stateLoading.classList.add('active');
                this._animateLoadingText();
            } else {
                this.els.stateLoading.classList.remove('active');
                // Don't show empty state if we have results, so we do nothing here.
                // The logic calling this should ensure results are rendered.
            }
        }

        _animateLoadingText() {
            const steps = ["SHUFFLING...", "VERIFYING...", "GENERATING..."];
            let i = 0;
            this.els.loadingText.textContent = steps[0];
            const interval = setInterval(() => {
                if (!this.els.stateLoading.classList.contains('active')) {
                    clearInterval(interval); return;
                }
                i = (i + 1) % steps.length;
                this.els.loadingText.textContent = steps[i];
            }, 250);
        }

        renderResults(winners, backups) {
            // Force Clear
            this.els.resultContainer.innerHTML = ''; 
            
            const fragment = document.createDocumentFragment();
            const winnerGroup = this._createResultGroup('üéâ Ê≠£ÂèñÂêçÂñÆ', winners, 'winner');
            fragment.appendChild(winnerGroup);
            if (backups.length > 0) {
                const backupGroup = this._createResultGroup('‚ö†Ô∏è ÂÇôÂèñÂêçÂñÆ', backups, 'backup');
                fragment.appendChild(backupGroup);
            }
            this.els.resultContainer.appendChild(fragment);
            
            // Force repaint hack
            void this.els.resultContainer.offsetWidth;
            
            this._enableActions(true);
        }

        _createResultGroup(title, list, type) {
            const header = Utils.dom('div', { className: 'group-header' },
                Utils.dom('span', { text: title }),
                Utils.dom('span', { text: list.length > 0 ? `${list.length} ‰∫∫` : 'ÁÑ°' })
            );
            const scrollArea = Utils.dom('div', { className: 'list-scroll' });
            if (list.length === 0) {
                scrollArea.appendChild(Utils.dom('div', { style: { padding: '20px', textAlign: 'center', color: 'var(--color-text-muted)' }, text: '( ÁÑ° )' }));
            } else {
                const listFragment = document.createDocumentFragment();
                const renderCount = Math.min(list.length, CONFIG.UI.MAX_RENDER_ITEMS);
                for (let i = 0; i < renderCount; i++) {
                    const prefix = type === 'backup' ? 'B' : '';
                    const indexStr = `${prefix}${String(i + 1).padStart(2, '0')}`;
                    const row = Utils.dom('div', { className: 'result-row' },
                        Utils.dom('span', { className: 'index', text: indexStr }),
                        Utils.dom('span', { className: 'name', text: list[i] })
                    );
                    listFragment.appendChild(row);
                }
                if (list.length > CONFIG.UI.MAX_RENDER_ITEMS) {
                    listFragment.appendChild(Utils.dom('div', { style: { padding: '8px', textAlign: 'center', color: 'var(--color-text-muted)', fontSize: '0.8rem' }, text: `...ÈÇÑÊúâ ${list.length - renderCount} ‰∫∫ (Ë´ã‰∏ãËºâÂÆåÊï¥Â†±Âëä)` }));
                }
                scrollArea.appendChild(listFragment);
            }
            return Utils.dom('div', { className: `result-group ${type}` }, header, scrollArea);
        }

        _enableActions(enabled) {
            this.els.btnCopy.disabled = !enabled;
            this.els.btnDownload.disabled = !enabled;
        }

        showCopyFeedback() {
            const btn = this.els.btnCopy;
            const originalContent = btn.innerHTML;
            btn.classList.add('copied');
            btn.innerHTML = '<span>‚úîÔ∏è Â∑≤Ë§áË£Ω</span>';
            setTimeout(() => {
                btn.classList.remove('copied');
                btn.innerHTML = originalContent;
            }, 2000);
        }
    }

    class App {
        constructor() {
            this.engine = new LotteryEngine();
            this.ui = new UIManager();
            this.toast = new ToastService();
            this.modal = new ModalService();
            this.state = { currentReport: '' };
            this.inputs = {
                names: document.getElementById('input-names'),
                countMain: document.getElementById('input-count-main'),
                countBackup: document.getElementById('input-count-backup'),
                toggleMemory: document.getElementById('toggle-memory'),
                toggleDedup: document.getElementById('toggle-dedup'),
                btnClear: document.getElementById('btn-clear')
            };
            this.init();
        }

        init() {
            this.loadSettings();
            this.bindEvents();
            this.handleInputChange();
        }

        loadSettings() {
            const getBool = (key, def) => { const val = Utils.safeStorageGet(key); return val === null ? def : val === 'true'; };
            this.inputs.toggleMemory.checked = getBool(CONFIG.STORAGE_KEYS.MEMORY_ENABLED, false);
            this.inputs.toggleDedup.checked = getBool(CONFIG.STORAGE_KEYS.DEDUP_ENABLED, true);
            if (this.inputs.toggleMemory.checked) {
                this.inputs.names.value = Utils.safeStorageGet(CONFIG.STORAGE_KEYS.NAMES) || '';
            }
        }

        bindEvents() {
            this.inputs.names.addEventListener('input', Utils.debounce(() => this.handleInputChange(), 300));
            const bindToggle = (el, key, msg) => {
                el.addEventListener('change', (e) => {
                    Utils.safeStorageSet(key, e.target.checked);
                    if (key === CONFIG.STORAGE_KEYS.DEDUP_ENABLED) this.handleInputChange();
                    if (key === CONFIG.STORAGE_KEYS.MEMORY_ENABLED) this.handleMemoryToggle();
                    this.toast.show(msg, 'success');
                });
            };
            bindToggle(this.inputs.toggleMemory, CONFIG.STORAGE_KEYS.MEMORY_ENABLED, "Ë®òÊÜ∂ÂäüËÉΩÂ∑≤Êõ¥Êñ∞");
            bindToggle(this.inputs.toggleDedup, CONFIG.STORAGE_KEYS.DEDUP_ENABLED, "ÂéªÈáçÂäüËÉΩÂ∑≤Êõ¥Êñ∞");
            this.inputs.btnClear.onclick = () => this.requestClear();
            this.ui.els.btnRun.onclick = () => this.runLottery();
            this.ui.els.btnCopy.onclick = () => this.copyResult();
            this.ui.els.btnDownload.onclick = () => this.downloadResult();
        }

        handleInputChange() {
            const raw = this.inputs.names.value;
            const isDedup = this.inputs.toggleDedup.checked;
            const processedNames = this.engine.processInput(raw, isDedup);
            this.ui.updatePreview(processedNames);
            if (this.inputs.toggleMemory.checked) { Utils.safeStorageSet(CONFIG.STORAGE_KEYS.NAMES, raw); }
        }

        handleMemoryToggle() {
            if (this.inputs.toggleMemory.checked) { Utils.safeStorageSet(CONFIG.STORAGE_KEYS.NAMES, this.inputs.names.value); }
            else { Utils.safeStorageRemove(CONFIG.STORAGE_KEYS.NAMES); }
        }

        requestClear() {
            if (!this.inputs.names.value) return;
            this.modal.confirm("Á¢∫Ë™çÊ∏ÖÁ©∫", "ÊÇ®Á¢∫ÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâËº∏ÂÖ•ÁöÑÂêçÂñÆÂóéÔºü", () => {
                this.inputs.names.value = '';
                this.handleInputChange();
                this.toast.show("ÂêçÂñÆÂ∑≤Ê∏ÖÁ©∫");
            });
        }

        async runLottery() {
            const isDedup = this.inputs.toggleDedup.checked;
            const names = this.engine.processInput(this.inputs.names.value, isDedup);
            const mainCount = parseInt(this.inputs.countMain.value) || 0;
            const backupCount = parseInt(this.inputs.countBackup.value) || 0;

            if (names.length === 0) return this.toast.show("Ë´ãÂÖàËº∏ÂÖ•ÂêçÂñÆ", "error");
            if (mainCount <= 0) return this.toast.show("Ê≠£Âèñ‰∫∫Êï∏ÂøÖÈ†àÂ§ßÊñº 0", "error");

            const execute = async () => {
                // Clear UI first
                this.ui.els.resultContainer.innerHTML = '';
                
                this.ui.setLoading(true);
                await new Promise(resolve => setTimeout(resolve, CONFIG.UI.ANIMATION_DELAY));

                try {
                    const result = this.engine.draw(names, mainCount, backupCount);
                    this.ui.renderResults(result.winners, result.backups);
                    this.state.currentReport = this.engine.formatReport(result.winners, result.backups, names.length);
                    this.toast.show("ÊäΩÈÅ∏ÂÆåÊàê", "success");
                } catch (e) {
                    console.error("Lottery Error:", e);
                    this.toast.show("ÊäΩÈÅ∏Â§±Êïó (Ë´ãÊü•Áúã Console)", "error");
                } finally {
                    this.ui.setLoading(false);
                }
            };

            if (names.length < (mainCount + backupCount)) {
                this.modal.confirm("‰∫∫Êï∏‰∏çË∂≥Ë≠¶Âëä", `ÂêçÂñÆ‰∫∫Êï∏ (${names.length}) Â∞ëÊñºÁ∏ΩÈúÄÊ±Ç (${mainCount + backupCount})„ÄÇÊòØÂê¶ÁπºÁ∫åÔºü`, execute);
            } else {
                execute();
            }
        }

        copyResult() {
            if (!this.state.currentReport) return;
            navigator.clipboard.writeText(this.state.currentReport)
                .then(() => { this.toast.show("Â∑≤Ë§áË£ΩÂ†±Âëä"); this.ui.showCopyFeedback(); })
                .catch(() => this.toast.show("Ë§áË£ΩÂ§±Êïó", "error"));
        }

        downloadResult() {
            if (!this.state.currentReport) return;
            const blob = new Blob([this.state.currentReport], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = Utils.generateFilename();
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    }

    document.addEventListener('DOMContentLoaded', () => { window.app = new App(); });
</script>
</body>
</html>
